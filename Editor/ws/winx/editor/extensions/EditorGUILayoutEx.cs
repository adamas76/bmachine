// ------------------------------------------------------------------------------
//  <autogenerated>
//      This code was generated by a tool.
//      Mono Runtime Version: 4.0.30319.1
// 
//      Changes to this file may cause incorrect behavior and will be lost if 
//      the code is regenerated.
//  </autogenerated>
// ------------------------------------------------------------------------------
using System;
using UnityEngine;
using UnityEditor;
using System.Collections.Generic;
using System.Collections;
using ws.winx.unity;
using ws.winx.editor.extensions;
using System.Reflection;
using System.Linq;
using BehaviourMachine;

namespace ws.winx.editor.extensions
{
		public class EditorGUILayoutEx
		{

//				private static object SELECTED_OBJECT = null;
				private static int CONTROL_ID = -1;
				private static int SELECTED_INDEX = -1;
				private static IList CHANGED_VALUES = null;
				private static GUIContent[] __unityTypesDisplayOptions;

				public static GUIContent[] unityTypesDisplayOptions {
						get {
								if (__unityTypesDisplayOptions == null) {
										__unityTypesDisplayOptions = new GUIContent[] {
												new GUIContent ("float"),
												new GUIContent ("int"),
												new GUIContent ("bool"),
												new GUIContent ("string"),
												new GUIContent ("Vector3"),
												new GUIContent ("Quaternion"),
												new GUIContent ("Color"),
												new GUIContent ("Material"),
												new GUIContent ("Texture2D"),
												new GUIContent ("Texture3D"),
												new GUIContent ("GameObject"),
												new GUIContent ("AnimationCurve"),
												new GUIContent ("AnimationClip")
										};
				

								}
								return __unityTypesDisplayOptions;
						}
				}

				private static Type[] __unityTypes;
						                                                              
				public static Type[] unityTypes {
						get {
								if (__unityTypes == null) {
										__unityTypes = new Type[] {
												typeof(float),
												typeof(int),
												typeof(bool),
												typeof(string),
												typeof(Vector3),
												typeof(Quaternion),
												typeof(Color),
												typeof(Material),
												typeof(Texture2D),
												typeof(Texture3D),
												typeof(GameObject),
												typeof(AnimationCurve),
												typeof(AnimationClip)
										};                        

								}
								return __unityTypes;
						}
	
				}

				private static Texture __eventMarkerTexture;

				public static Texture eventMarkerTexture {
						get {
								if (__eventMarkerTexture == null)
										__eventMarkerTexture = EditorGUIUtility.IconContent ("Animation.EventMarker").image;

								return __eventMarkerTexture;
						}
				}

				public delegate void MenuCallaback<T> (int selectedIndex,T SelectedObject,int controlID);

				public delegate void EventCallback (int ownerControlID,Event e);

				public delegate void ObjectPropertyCallback (UnityEngine.Object @object,Type type,string property);




				//
				// Nested Types
				//
				private class ToolTipStyles
				{
					
						public GUIStyle tooltipBackground = "AnimationEventTooltip";
						public GUIStyle tooltipArrow = "AnimationEventTooltipArrow";

				}
				
				private static ToolTipStyles TOOLTIP_STYLES;


				
			

		#region CustomHSlider

		public static float CustomHSlider (Rect rect,float timeCurrent,float timeStart,float timeStop)
		{

			Event current = Event.current;
			int controlID = GUIUtility.GetControlID (FocusType.Passive);//TimeControl.kScrubberIDHash, FocusType.Keyboard);
			Rect rect2 = rect;
			rect2.height = 21f;
			Rect rect3 = rect2;


			float m_MouseDrag = 0f;
			bool mouseInteract = false;



			switch (current.GetTypeForControl (controlID))
			{
			case EventType.MouseDown:
				if (rect.Contains (current.mousePosition))
				{
					GUIUtility.keyboardControl = controlID;
				}
				if (rect3.Contains (current.mousePosition))
				{
					EditorGUIUtility.SetWantsMouseJumping (1);
					GUIUtility.hotControl = controlID;
					m_MouseDrag = Mathf.Clamp(current.mousePosition.x - rect3.xMin,0,rect3.xMax);
					timeCurrent = m_MouseDrag * (timeStop - timeStart) / rect3.width + timeStart;
				
					mouseInteract=true;
					current.Use ();
				}
				break;
			case EventType.MouseUp:
				if (GUIUtility.hotControl == controlID)
				{
					EditorGUIUtility.SetWantsMouseJumping (0);
					GUIUtility.hotControl = 0;
					current.Use ();
				}
				break;
			case EventType.MouseDrag:
				if (GUIUtility.hotControl == controlID)
				{
					m_MouseDrag = Mathf.Clamp(current.mousePosition.x - rect3.xMin,0,rect3.xMax);
					timeCurrent = Mathf.Clamp (m_MouseDrag, 0f, rect3.width) * (timeStop - timeStart) / rect3.width + timeStart;
					mouseInteract=true;
					current.Use ();
				}
				break;
			case EventType.KeyDown:
				if (GUIUtility.keyboardControl == controlID)
				{
					if (current.keyCode == KeyCode.LeftArrow)
					{
//						if (this.currentTime - this.startTime > 0.01f)
//						{
//							this.deltaTime = -0.01f;
//						}
						current.Use ();
					}
					if (current.keyCode == KeyCode.RightArrow)
					{
//						if (this.stopTime - this.currentTime > 0.01f)
//						{
//							this.deltaTime = 0.01f;
//						}
						current.Use ();
					}
				}
				break;
			}

			GUI.Box (rect2, GUIContent.none, TimeControlW.style.timeScrubber);
		
			if (GUIUtility.keyboardControl == controlID)
			{
				Handles.color = new Color (1f, 0f, 0f, 1f);
			}
			else
			{
				Handles.color = new Color (1f, 0f, 0f, 0.5f);
			}


			if(!mouseInteract)
				m_MouseDrag=rect3.xMin+((timeCurrent - timeStart) * (rect3.width))/(timeStop - timeStart);
		

			Handles.DrawLine (new Vector2 (m_MouseDrag, rect3.yMin), new Vector2 (m_MouseDrag, rect3.yMax));



		


			return timeCurrent;
		}
		#endregion
	


		#region CustomPopup
				/// <summary>
				/// Custom popup.
				/// </summary>
				/// <returns>The popup.</returns>
				/// <param name="label">Label.</param>
				/// <param name="selectedIndex">Selected index.</param>
				/// <param name="displayOptions">Display options.</param>
				/// <param name="values">Values.</param>
				/// <param name="onSelection">On selection.</param>
				/// <param name="onEvent">On event.</param>
				/// <param name="style">Style.</param>
				/// <param name="position">Position.</param>
				/// <typeparam name="T">The 1st type parameter.</typeparam>
				public static int CustomPopup<T> (GUIContent label, int selectedIndex, GUIContent[] displayOptions, IList<T> values,
		                                 MenuCallaback<T> onSelection=null,
		                                 EventCallback onEvent=null,
		                                 GUIStyle style=null,
		                                  UnityEngine.Rect? position=null
		                                
				)
				{
						GUIContent content;
						string buttonLabel = null;
						int i = 0;
						int len;
						int inxd;
					

						if (!position.HasValue)
								EditorGUILayout.BeginHorizontal ();
						


			
						//add Label field
						// Screen.width in insprector returns its width not Screen => so 35% for the lable and rest for the popup button
						if (style != null && label != null) {
								if (position.HasValue)
										EditorGUI.LabelField (position.Value, label, style);
								else
										EditorGUILayout.LabelField (label, style, GUILayout.Width (Screen.width * 0.35f));
										
						} else 	if (label != null) {
							
								if (position.HasValue)
										position = EditorGUI.PrefixLabel (position.Value, label);
								else
										EditorGUILayout.LabelField (label, GUILayout.Width (Screen.width * 0.35f));
										
						}
			
			
						//						//get current control ID
						int controlID = GUIUtility.GetControlID (FocusType.Passive) + 1;
			
						//if current == previous selected control => asign "selectedObject" and reset global
						if (controlID == EditorGUILayoutEx.CONTROL_ID) {
								selectedIndex = EditorGUILayoutEx.SELECTED_INDEX;
				
								//reset
								//	EditorGUILayoutEx._CustomPopup_SelectedObject = null;
								EditorGUILayoutEx.SELECTED_INDEX = -1;
								EditorGUILayoutEx.CONTROL_ID = -1;
						}
			
						//if selectionObject is null on Init
						if (selectedIndex < 0) {
				
				
								inxd = len = displayOptions.Length;
				
								//set "selectedObject" to first values[i] that is Enable
								for (i=0; i<len; i++) {
										buttonLabel = displayOptions [i].text;
					
										//check if contains "*" disable mark
										if (buttonLabel.LastIndexOf ('*', buttonLabel.Length - 1) > -1)
												continue;
					
										inxd = i;
										break;
					
								}
				
								//if we have found value[i] which is Enabled => set selectObject to it
								if (inxd < len) {
										//remove submenu's mark "/"
										buttonLabel = buttonLabel.Substring (buttonLabel.LastIndexOf ("/") + 1);		
										selectedIndex = inxd;
								}
				
						} else {
				
								//find label on displayOptions[i] which is value[i] == selectedObject
								buttonLabel = displayOptions [selectedIndex].text;
				
								//remove submenus mark "/"
								buttonLabel = buttonLabel.Substring (buttonLabel.LastIndexOf ("/") + 1);
				
				
						}
			
			
						//Debug.Log ("SelectedIndex:"+selectedIndex);
			
			
						//dispatch events
						if (onEvent != null && controlID == GUIUtility.hotControl) {
								onEvent (controlID, Event.current);
						}
						//								switch (Event.current.GetTypeForControl (controlID)) {
						//								case EventType.mouseDown://never triggered
						//										Debug.Log ("Event " + Event.current.type);
						//
						//										break;
						//								case EventType.mouseUp:
						//										Debug.Log ("Event " + Event.current.type);
						//										break;
						//			default:
						//				Debug.Log ("Event "+Event.current.type);
						//				break;
						//			}
			
						bool clicked;

						if (position.HasValue)
								clicked = GUI.Button (position.Value, buttonLabel, EditorStyles.popup);
						else
								clicked = GUILayout.Button (new GUIContent (buttonLabel), EditorStyles.popup);
			
						if (clicked) {
				
								//shoot custom MouseDown event here!!!
				
								// Now create the menu, add items and show it
								GenericMenu menu = new GenericMenu ();
				
								len = displayOptions.Length;
				
								for (i=0; i<len; i++) {
					
										content = displayOptions [i];
					
										// null mean AddSeparator
										if (content == null)
												menu.AddSeparator ("");
					// "*" at the end => mean AddDisabledItem
					else if (content.text.LastIndexOf ('*', content.text.Length - 1) > -1) {
												content.text = content.text.Remove (content.text.Length - 1);
												menu.AddDisabledItem (content);
										} else
												menu.AddItem (content, false, (obj) => {
														int inx = (int)obj;
														//EditorGUILayoutEx._CustomPopup_SelectedObject = values [inx];
														EditorGUILayoutEx.CONTROL_ID = controlID;
														EditorGUILayoutEx.SELECTED_INDEX = inx;
							
														//Debug.Log ("Selected:" + inx);	
							
														//dispatch selected
														if (onSelection != null)
																onSelection (inx, values [inx], controlID);
							
												}, i);
								}
				
				
				
								menu.ShowAsContext ();
						}

						if (!position.HasValue)
								EditorGUILayout.EndHorizontal ();

						return selectedIndex;
				}
		#endregion

		#region CustomObjectPopup
				public static T CustomObjectPopup<T> (GUIContent label, T selectedObject, GUIContent[] displayOptions, IList<T> values,
		                                      MenuCallaback<T> onSelection=null,
		                                      EventCallback onEvent=null,
		                                      GUIStyle labelStyle=null,
		                                      UnityEngine.Rect? position=null
		                                      
				)
				{

						int inxOfSelectedObject;
						int len;
						int i;
						string buttonLabel;
			
			
						if (displayOptions == null || values == null) {
								Debug.LogError ("Display options or values shouldn't be NULL");
								return default(T);
						}

						if ((displayOptions != null && displayOptions.Length == 0) || (values != null && values.Count == 0)) {
								return default(T);
						}


			
			
						//if selectionObject is null on Init
						if (selectedObject == null) {
				
				
								inxOfSelectedObject = len = displayOptions.Length;
				
								//find index of "selectedObject" that is Enable
								for (i=0; i<len; i++) {
										buttonLabel = displayOptions [i].text;
					
										//check if contains "*" disable mark
										if (buttonLabel.LastIndexOf ('*', buttonLabel.Length - 1) > -1)
												continue;
					
										inxOfSelectedObject = i;
										break;
					
								}
				
								//if we have found value[i] which is Enabled => set selectObject to it
								if (inxOfSelectedObject < len) {
					
										selectedObject = values [inxOfSelectedObject];
										CustomPopup (label, inxOfSelectedObject, displayOptions, values, onSelection, onEvent, labelStyle, position);
								}
				
						} else {
				
								//find label on displayOptions[i] which is value[i] == selectedObject
								inxOfSelectedObject = values.IndexOf (selectedObject);
								//Array.IndexOf (values, selectedObject);

				
								inxOfSelectedObject = CustomPopup (label, inxOfSelectedObject, displayOptions, values, onSelection, onEvent, labelStyle, position);
				
								selectedObject = values [inxOfSelectedObject];
				
				
						}
			
			
			
			
			
			
						return selectedObject;

				}

		#endregion


		#region CustomTooltip

				public static void  CustomTooltip (Rect positionRect, string text)
				{
		
						if (EditorGUILayoutEx.TOOLTIP_STYLES == null) {
								EditorGUILayoutEx.TOOLTIP_STYLES = new EditorGUILayoutEx.ToolTipStyles ();
						}
						GUIStyle gUIStyle = EditorGUILayoutEx.TOOLTIP_STYLES.tooltipArrow;
						Vector2 arrowSize = gUIStyle.CalcSize (new GUIContent ());
		
		
		
												
						GUI.Label (new Rect (positionRect.x - arrowSize.x * 0.5f - 5f, positionRect.y + positionRect.height, arrowSize.x, arrowSize.y), string.Empty, gUIStyle);
												
		
		
						gUIStyle = EditorGUILayoutEx.TOOLTIP_STYLES.tooltipBackground;
						Vector2 textSize = gUIStyle.CalcSize (new GUIContent (text));
						gUIStyle.alignment = TextAnchor.MiddleCenter;
		
		
		
												
						GUI.Label (new Rect (positionRect.x + arrowSize.x * 0.5f - Mathf.Max (arrowSize.x, textSize.x) * 0.5f, positionRect.y + positionRect.height + arrowSize.y, Mathf.Max (arrowSize.x, textSize.x), textSize.y), text, gUIStyle);
												

				}
		#endregion

		#region CustomTimeLine
				//
				// Methods
				//
		
				/// <summary>
				/// Gets the index of the mouse hover rect.
				/// </summary>
				/// <returns>The mouse hover rect index.</returns>
				/// <param name="postionRect">Postion rect.</param>
				/// <param name="values">Values.</param>
				/// <param name="hitRects">Hit rects.</param>
				/// <param name="controlID">Control I.</param>
				private static int GetMouseHoverRectIndex (Rect postionRect, float[] values, Rect[] hitRects)
				{
						Vector2 mousePosition = Event.current.mousePosition;
						
						if (values.Length == hitRects.Length) {
								for (int i = hitRects.Length - 1; i >= 0; i--) {
										if (hitRects [i].Contains (mousePosition)) {
						
						
						
												return i;
										}
								}
						}
			
						return -1;
				}
		
		
				/// <summary>
				/// Deletes the events.
				/// </summary>
				/// <param name="args">Arguments.</param>
				/// <param name="deleteIndices">Delete indices.</param>
				private static void DeleteTimeValues (TimeLineArgs<float> args, bool[] deleteIndices)
				{
			
						List<float> list = new List<float> (args.values);
			
			
						for (int i = list.Count  - 1; i >= 0; i--) {
				
								if (deleteIndices [i]) {
										list.RemoveAt (i);
					
								}
						}
			
						if (list.Count < args.values.Count) {
				
								if (args.EditClose != null)
										args.EditClose (args);
				
				
								CHANGED_VALUES = list.ToArray ();
								CONTROL_ID = args.controlID;
				
				
				
				
				
								if (args.Delete != null)
										args.Delete (new TimeLineArgs<float> (-1, 0f, (float[])CHANGED_VALUES, null, args.controlID));
						}
				}
		
		
		
		
				/// <summary>
				/// Ons the add.
				/// </summary>
				/// <param name="obj">Object.</param>
				private static void onAdd (System.Object obj)
				{
						//Debug.Log ("onAdd");
						TimeLineArgs<float> args = (TimeLineArgs<float>)obj;
			
			
						int newTimeValueInx = args.values.Count;
			
						//find first time > then current and insert before it
						for (int i = 0; i < newTimeValueInx; i++) {
								if (args.values [i] > args.selectedValue) {
										newTimeValueInx = i;
										break;
								}
						}
			
						float[] timeValues = new float[args.values.Count];
						args.values.CopyTo (timeValues, 0);
			
			
			
						ArrayUtility.Insert<float> (ref timeValues, newTimeValueInx, args.selectedValue);
			
			
			
						CONTROL_ID = args.controlID;
						CHANGED_VALUES = timeValues;
			
			
			
						//open editor for newely added 
						if (args.Add != null)
								args.Add (new TimeLineArgs<float> (newTimeValueInx, args.selectedValue, timeValues, null, args.controlID));
				}
		
				/// <summary>
				/// Ons the delete.
				/// </summary>
				/// <param name="obj">Object.</param>
				private static void onDelete (System.Object obj)
				{
						TimeLineArgs<float> args = (TimeLineArgs<float>)obj;
			
						int index = args.selectedIndex;
						if (args.selected [index]) {
								DeleteTimeValues (args, args.selected);
						} else {
								bool[] timeValuesSelected = new bool[args.selected.Length];
								timeValuesSelected [index] = true;
								DeleteTimeValues (args, timeValuesSelected);
						}
			
			
				}
		
				/// <summary>
				/// Ons the edit.
				/// </summary>
				/// <param name="obj">Object.</param>
				private static void onEdit (System.Object obj)
				{
						TimeLineArgs<float> args = (TimeLineArgs<float>)obj;
			
						if (args.EditOpen != null) {
								args.EditOpen (args);
						}
			
			
				}
		
		
				/// <summary>
				/// Ons the context click on time value.
				/// </summary>
				/// <param name="args">Arguments.</param>
				private static void onContextClickOnTimeValue (TimeLineArgs<float> args)
				{
			
						GenericMenu genericMenu = new GenericMenu ();
						genericMenu.AddItem (new GUIContent ("Edit"), false, new GenericMenu.MenuFunction2 (onEdit), args);
						genericMenu.AddItem (new GUIContent ("Add"), false, new GenericMenu.MenuFunction2 (onAdd), args);
						genericMenu.AddItem (new GUIContent ("Delete"), false, new GenericMenu.MenuFunction2 (onDelete), args);
						genericMenu.ShowAsContext ();
			
				}
		
		
				/// <summary>
				/// Ons the context click.
				/// </summary>
				/// <param name="args">Arguments.</param>
				private static void onContextClick (TimeLineArgs<float> args)
				{
						//Debug.Log ("ContextClick on empty");
						Event.current.Use ();
						GenericMenu genericMenu2 = new GenericMenu ();
						genericMenu2.AddItem (new GUIContent ("Add"), false, new GenericMenu.MenuFunction2 (onAdd), args);
						genericMenu2.ShowAsContext ();
				}

				public static GenericMenu GeneraterGenericMenu<T> (GUIContent[] displayOptions, IList<T> values, GenericMenu.MenuFunction2 callback)
				{
					
						GenericMenu genericMenu = new GenericMenu ();
						int count = displayOptions.Length;
						for (int i=0; i<count; i++) {

								genericMenu.AddItem (displayOptions [i], false, callback
											, values [i]);
						}


						return genericMenu;
				}
		
		
				/// <summary>
				/// Customs the time line.
				/// </summary>
				/// <param name="rectGlobal">Rect global.</param>
				/// <param name="timeValues">Time values.</param>
				/// <param name="timeValuesTime">Internal purpose. Time values at drag start (just pass reference).</param>
				/// <param name="displayNames">Display names.</param>
				/// <param name="selected">Selected. Array true/false values of thoose selected</param>
				/// <param name="timeInput">Time. (0 to 1f) or -1 if not used mouse click position would be used</param>
				/// <param name="Add">Add.</param>
				/// <param name="Delete">Delete.</param>
				/// <param name="EditClose">Edit close.</param>
				/// <param name="EditOpen">Edit open.</param>
				/// <param name="DragEnd">Drag end.</param>
				public static void CustomTimeLine (ref Rect rectGlobal, ref float[] timeValues, ref float[] timeValuesTime, ref string[] displayNames, ref bool[] selected, float timeInput=-1,
		                                   Action<TimeLineArgs<float>> Add=null, Action<TimeLineArgs<float>> Delete=null, Action<TimeLineArgs<float>> EditClose=null, Action<TimeLineArgs<float>> EditOpen=null, Action<TimeLineArgs<float>> DragEnd=null
				)
				{
						
					

			
						int controlID = GUIUtility.GetControlID (FocusType.Passive) + 1;
						//Debug.Log ("Cid:" + controlID + " " + GUIEditorGUILayoutEx.hotControl);
			
						if (controlID == CONTROL_ID) {
								CONTROL_ID = -1;
								timeValues = (float[])CHANGED_VALUES;
				
								CHANGED_VALUES = null;
						}
			
						GUI.BeginGroup (rectGlobal);
						
						Color color = GUI.color;
			
						Rect rectLocal = new Rect (0f, 0f, rectGlobal.width, rectGlobal.height);
			
						//background
						//GUI.Box (rectLocal, GUIContent.none);
						rectLocal.width -= eventMarkerTexture.width;
			
			
			
						//if time less then zero use mouse position for Add otherwise use outside value 

						float time = 0f;
						if (rectLocal.Contains (Event.current.mousePosition)) {
								time = (float)Math.Round (Event.current.mousePosition.x / rectLocal.width, 4);
				 					
						}

			
			
			
						int timeValuesNumber = timeValues.Length;
						Rect[] positionsHitRectArray = new Rect[timeValuesNumber];
						Rect[] positionsRectArray = new Rect[timeValuesNumber];
						int timeValuesNumberOfTheSame = 0;//items that have same time

						//mulitiplier simple changes the y position of the timeValue handle so
						//same timeValues's hanldes are on of top of another
			
						float[] timeValuesTheSameHightMultiply = new float[timeValuesNumber]; 
						float timeValue;
						int i = 0;
						int fromToEndInx = 0;
			
						float timeValuePositionX = 0f;
			
			
			
			
						for (i = 0; i < timeValuesNumber; i++) {
				
				
								timeValue = timeValues [i];
								timeValuePositionX = timeValue * rectLocal.width;
								timeValuesNumberOfTheSame = 0;
				
								//version 1 display one tube no visible separtion od handles
								//								if (timeValuesTheSameHightMultiply [i] == 0) {
								//										//find other with same value and record multiply (1x,2x,...)
								//										for (fromToEndInx=i+1; fromToEndInx < timeValuesNumber; fromToEndInx++) {
								//												if (timeValues [fromToEndInx] == timeValue) {
								//														timeValuesNumberOfTheSame++;
								//														timeValuesTheSameHightMultiply [fromToEndInx] = timeValuesNumberOfTheSame;
								//												}
								//										
								//										}
								//								}
				
				
				
								//version 2 display has visible separation of handles when they have same time
								if (timeValuesTheSameHightMultiply [i] == 0) {
										//find other with same value and record multiply (1x,2x,...)
										for (fromToEndInx=timeValuesNumber-1; fromToEndInx > i; fromToEndInx--) {
												if (timeValues [fromToEndInx] == timeValue) {
							
														timeValuesTheSameHightMultiply [fromToEndInx] = timeValuesNumberOfTheSame;
														timeValuesNumberOfTheSame++;
												}
						
										}
					
										timeValuesTheSameHightMultiply [i] = timeValuesNumberOfTheSame;
								}
				
				
				
				
				
				
				
				
								Rect rect3 = new Rect (timeValuePositionX, eventMarkerTexture.height * timeValuesTheSameHightMultiply [i] * 0.66f, (float)eventMarkerTexture.width, (float)eventMarkerTexture.height);
				
				
								positionsHitRectArray [i] = rect3;
								positionsRectArray [i] = rect3;
						}
			
			
			
			
			
			
			
						if (selected == null || selected.Length != timeValuesNumber) {
								selected = new bool[timeValuesNumber];
				
								if (EditClose != null)
										EditClose (null);
				
				
				
						}
			
			
			
			
						Vector2 offset = Vector2.zero; 
						int clickedIndex;
						float startSelect;
						float endSelect;
			
						HighLevelEvent highLevelEvent = EditorGUIExtW.MultiSelection (rectGlobal, positionsRectArray, new GUIContent (__eventMarkerTexture), positionsHitRectArray, ref selected, null, out clickedIndex, out offset, out startSelect, out endSelect, GUIStyle.none);
			
			
			
						if (highLevelEvent != HighLevelEvent.None) {
								switch (highLevelEvent) {
								case HighLevelEvent.DoubleClick:
										if (clickedIndex != -1) {
												if (EditOpen != null) {
														EditOpen (new TimeLineArgs<float> (clickedIndex, timeValues [clickedIndex], timeValues, selected, controlID));
							
												}
						
										} else {
												//never enters here???
												if (timeInput >= 0)
														time = timeInput;
												onAdd (new TimeLineArgs<float> (clickedIndex, time, timeValues, selected, controlID, Add));
						
										}
										break;
					
								case HighLevelEvent.ContextClick:
										{
					
												//Debug.Log ("ContextClick on handle");
												selected = new bool[timeValuesNumber];
												selected [clickedIndex] = true;

												if (timeInput >= 0)
														time = timeInput;
												else
														time = timeValues [clickedIndex];
												onContextClickOnTimeValue (new TimeLineArgs<float> (clickedIndex, time, timeValues, selected, controlID, Add, Delete, EditClose, EditOpen));
					
					
												break;
										}
					
								case HighLevelEvent.BeginDrag:
					
										timeValuesTime = (float[])timeValues.Clone ();
					
					//										//copy values when begin to drag	
					//										for (int j = 0; j < timeValues.Length; j++) {
					//												timeValuesTime [j] = timeValues [j];
					//										}
					
					
					
					
										break;
								case HighLevelEvent.Drag:
										{
					
												for (int k = timeValues.Length - 1; k >= 0; k--) {
														if (selected [k]) {
							
																timeValues [k] = (float)Math.Round (timeValuesTime [k] + offset.x / rectLocal.width, 4);
							
																if (timeValues [k] > 1f)
																		timeValues [k] = 1f;
																else if (timeValues [k] < 0f)
																		timeValues [k] = 0f;
																//Debug.Log ("Dragged time" + timeValues [k]);
														}
												}
					
					
					
					
					
												break;
										}
					
								case HighLevelEvent.EndDrag:
					//Debug.Log("EndDrag");
										if (DragEnd != null) {
												DragEnd (new TimeLineArgs<float> (clickedIndex, time, timeValues, selected, controlID));
										}
					
										break;
								case HighLevelEvent.Delete:
										DeleteTimeValues (new TimeLineArgs<float> (clickedIndex, time, timeValues, selected, controlID, null, Delete), selected);
										break;
								case HighLevelEvent.SelectionChanged:

				//	Debug.Log("SelectionChanged");
					
										if (clickedIndex > -1) {
						
												
						
												if (EditOpen != null) {
														EditOpen (new TimeLineArgs<float> (clickedIndex, timeValues [clickedIndex], timeValues, selected, controlID));
							
												}
												
												
						
										} else

												selected = new bool[timeValuesNumber];
										break;
								}
						}
			
			
						int hoverInx = -1; 
						hoverInx = GetMouseHoverRectIndex (rectGlobal, timeValues, positionsHitRectArray);
			
			
						if (hoverInx > 0 && Event.current.button == 1 && Event.current.isMouse) {
				
								Event.current.Use ();
								selected = new bool[timeValuesNumber];
								selected [hoverInx] = true;
							
								if (timeInput >= 0)
										time = timeInput;
								else
										time = timeValues [hoverInx];
								onContextClickOnTimeValue (new TimeLineArgs<float> (hoverInx, time, timeValues, selected, controlID, Add, Delete, EditClose, EditOpen));
				
						}
			
			
			
						//HighLevelEvent.ContextClick doens't raize when mouse right click so =>
						if (Event.current.type == EventType.ContextClick && rectLocal.Contains (Event.current.mousePosition) 
								|| (Event.current.button == 1 && Event.current.isMouse)) {
				
								if (timeInput >= 0)
										time = timeInput;
								onContextClick (new TimeLineArgs<float> (clickedIndex, time, timeValues, selected, controlID, Add));
				
				
				
				
						}
			
						GUI.color = color;
			
						GUI.EndGroup ();
			
						//show tooltip on hover
						if (hoverInx >= 0 && hoverInx < positionsHitRectArray.Length) {
				
				
								Rect positionRect = positionsRectArray [hoverInx];
				
								//from local to global
								positionRect.y += rectGlobal.y;
								positionRect.x += rectGlobal.x;
				
				
				
								EditorGUILayoutEx.CustomTooltip (positionRect, displayNames [hoverInx] + "[" + timeValues [hoverInx] + "]");
				
						}
			
			
			
				}
		#endregion




		#region Draw Variables
				public static Rect DrawVector3Var (Rect rect, UnityVariable variable)
				{
						Rect rectOrg = new Rect (rect.x, rect.y, rect.width, rect.height);

						rect.width = Mathf.Max (Screen.width - 50, rect.width);
						rect.height = 21;

						rect.yMin = rect.yMin + 3f;
						rect.yMax = rect.xMax - 2f;
						rect.xMin = rect.xMin + 6f;
						rect.xMax = rect.xMax - 6f;
						DrawName (new Rect (rect.x, rect.y, 80f, 16f), variable);
						rect.xMin = rect.xMin + 84f;
						rect.xMax = rect.xMax - 19f;
						EditorGUI.BeginChangeCheck ();
						

						Vector3 vector = EditorGUI.Vector3Field (rect, string.Empty, (Vector3)variable.Value);
						if (EditorGUI.EndChangeCheck () && vector != (Vector3)variable.Value) {
			
								Undo.RecordObject (variable, "Variable Value");

								variable.Value = vector;

								EditorUtility.SetDirty (variable);

						}

						return rectOrg;
				}

				public static Rect DrawBoolVar (Rect rect, UnityVariable variable)
				{
						Rect rectOrg = new Rect (rect.x, rect.y, rect.width, rect.height);
			
						rect.width = Mathf.Max (Screen.width - 50, rect.width);
						rect.height = 21;

						rect.yMin = rect.yMin + 3f;
						rect.yMax = rect.yMax - 2f;
						rect.xMin = rect.xMin + 6f;
						rect.xMax = rect.xMax - 6f;
						EditorGUILayoutEx.DrawName (new Rect (rect.x, rect.y, 140f, rect.height), variable);
						rect.xMin = rect.xMin + 144f;
						rect.xMax = rect.xMax - 19f;
						EditorGUI.BeginChangeCheck ();
						bool flag = EditorGUI.Toggle (rect, GUIContent.none, (bool)variable.Value);
						if (EditorGUI.EndChangeCheck () && flag != (bool)variable.Value) {

								Undo.RecordObject (variable, "Variable Value");
			
								variable.Value = flag;

								EditorUtility.SetDirty (variable);

						}
						

						return rectOrg;

				}
		
				public static Rect DrawColorVar (Rect rect, UnityVariable variable)
				{
						Rect rectOrg = new Rect (rect.x, rect.y, rect.width, rect.height);
			
						rect.width = Mathf.Max (Screen.width - 50, rect.width);
						rect.height = 21;

						rect.yMin = rect.yMin + 3f;
						rect.yMax = rect.yMax - 2f;
						rect.xMin = rect.xMin + 6f;
						rect.xMax = rect.xMax - 6f;
						EditorGUILayoutEx.DrawName (new Rect (rect.x, rect.y, 120f, rect.height), variable);
						rect.xMin = rect.xMin + 124f;
						rect.xMax = rect.xMax - 19f;
						EditorGUI.BeginChangeCheck ();
						Color color = EditorGUI.ColorField (rect, GUIContent.none, (Color)variable.Value);
						if (EditorGUI.EndChangeCheck () && color != (Color)variable.Value) {

								Undo.RecordObject (variable, "Variable Value");

								variable.Value = color;

								EditorUtility.SetDirty (variable);
						}
						

						return rectOrg;
		
				}


		public static Rect DrawCurveVar (Rect rect, UnityVariable variable)
		{
			Rect rectOrg = new Rect (rect.x, rect.y, rect.width, rect.height);
			
			rect.width = Mathf.Max (Screen.width - 50, rect.width);
			rect.height = 21;
			
			rect.yMin = rect.yMin + 3f;
			rect.yMax = rect.yMax - 2f;
			rect.xMin = rect.xMin + 6f;
			rect.xMax = rect.xMax - 6f;
			EditorGUILayoutEx.DrawName (new Rect (rect.x, rect.y, 120f, rect.height), variable);
			rect.xMin = rect.xMin + 124f;
			rect.xMax = rect.xMax - 19f;
			EditorGUI.BeginChangeCheck ();
			AnimationCurve curve = EditorGUI.CurveField (rect, GUIContent.none, (AnimationCurve)variable.Value);
			if (EditorGUI.EndChangeCheck () && curve != (AnimationCurve)variable.Value) {
				
				Undo.RecordObject (variable, "Variable Value");
				
				variable.Value = curve;
				
				EditorUtility.SetDirty (variable);
			}
			
			
			return rectOrg;
			
		}
		
		public static Rect DrawFloatVar (Rect rect, UnityVariable variable)
				{
						Rect rectOrg = new Rect (rect.x, rect.y, rect.width, rect.height);

						rect.width = Mathf.Max (Screen.width - 50, rect.width);
						//rect.height = 21;


						rect.yMin = rect.yMin + 3f;
						rect.yMax = rect.yMax - 2f;
						rect.xMin = rect.xMin + 6f;
						rect.xMax = rect.xMax - 6f;
						EditorGUILayoutEx.DrawName (new Rect (rect.x, rect.y, 140f, rect.height), variable);
						rect.xMin = rect.xMin + 144f;
						rect.xMax = rect.xMax - 19f;
						EditorGUI.BeginChangeCheck ();
						float num = EditorGUI.FloatField (rect, GUIContent.none, (float)variable.Value);
						if (EditorGUI.EndChangeCheck () && num != (float)variable.Value) {

								Undo.RecordObject (variable, "Variable Value");

								variable.Value = num;

								EditorUtility.SetDirty (variable);

						}

						
		
						return rectOrg;

				}
		
				public static Rect DrawIntVar (Rect rect, UnityVariable variable)
				{

						Rect rectOrg = new Rect (rect.x, rect.y, rect.width, rect.height);
			
						rect.width = Mathf.Max (Screen.width - 50, rect.width);
						rect.height = 21;

						rect.yMin = rect.yMin + 3f;
						rect.yMax = rect.yMax - 2f;
						rect.xMin = rect.xMin + 6f;
						rect.xMax = rect.xMax - 6f;
						EditorGUILayoutEx.DrawName (new Rect (rect.x, rect.y, 140f, rect.height), variable);
						rect.xMin = rect.xMin + 144f;
						rect.xMax = rect.xMax - 19f;
						EditorGUI.BeginChangeCheck ();
						int num = EditorGUI.IntField (rect, GUIContent.none, (int)variable.Value);

						if (EditorGUI.EndChangeCheck () && num != (int)variable.Value) {

								Undo.RecordObject (variable, "Variable Value");

								variable.Value = num;

								EditorUtility.SetDirty (variable);
				
						}

		
						return rectOrg;
				}

				public static Rect DrawUnityObject (Rect rect, UnityVariable variable)
				{
						Rect rectOrg = new Rect (rect.x, rect.y, rect.width, rect.height);

						rect.width = Mathf.Max (Screen.width - 50, rect.width);
						rect.height = 21;


						rect.yMin = rect.yMin + 3f;
						rect.yMax = rect.yMax - 2f;
						rect.xMin = rect.xMin + 6f;
						rect.xMax = rect.xMax - 6f;
						EditorGUILayoutEx.DrawName (new Rect (rect.x, rect.y, 80f, rect.height), variable);
						rect.xMin = rect.xMin + 84f;
						rect.xMax = rect.xMax - 19f;
						EditorGUI.BeginChangeCheck ();
						UnityEngine.Object objectUnity = EditorGUI.ObjectField (rect, GUIContent.none, (UnityEngine.Object)variable.Value, variable.ValueType, true);
						if (EditorGUI.EndChangeCheck () && objectUnity != variable.Value) {

								Undo.RecordObject (variable, "Variable Value");

								variable.Value = objectUnity;

								EditorUtility.SetDirty (variable);

						}



						return rectOrg;

				}

				public static void DrawName (Rect rect, UnityVariable variable,bool editable=true)
				{

						if (!editable) {
								EditorGUI.LabelField (rect, variable.name);
						}

						EditorGUI.BeginChangeCheck ();

						string	text= EditorGUI.TextField (rect, variable.name);
						
							
						if (EditorGUI.EndChangeCheck () && text != variable.name) {

								Undo.RecordObject (variable, "Variable Name");

								variable.name = text;

						}
				}
//
//				private static Type __selectedType;
//
//				public static void DrawObjectPropVar (Rect rect, UnityVariable variable)
//				{
//						rect.width = Mathf.Max (Screen.width - 50, rect.width);
//						rect.yMin = rect.yMin + 3f;
//						rect.yMax = rect.yMax - 2f;
//						rect.xMin = rect.xMin + 6f;
//						rect.xMax = rect.xMax - 6f;
//						rect.height = rect.height - 18f;
//						EditorGUILayoutEx.DrawName (new Rect (rect.x, rect.y, 80f, rect.height), variable);
//						rect.xMin = rect.xMin + 84f;
//						rect.xMax = rect.xMax - 19f;
//				    
//						//Type 
//						EditorGUI.BeginChangeCheck ();
//
//						variable.reflectedInstance = EditorGUI.ObjectField (rect, GUIContent.none, (UnityEngine.Object)variable.reflectedInstance, typeof(UnityEngine.Object), true);
//					
//					
//
//						if (EditorGUI.EndChangeCheck () && variable.reflectedInstance != null) {
//						
//								Undo.RecordObject (variable, "Variable Value");
//						
//							
//						
//								EditorUtility.SetDirty (variable);
//
//
//
//								
//										rect.width = 100;
//										rect.xMin += 88f;
//								
//										//retruns 
//										__selectedType = EditorGUILayoutEx.CustomObjectPopup<Type> (null, variable.ValueType, EditorGUILayoutEx.unityTypesDisplayOptions, EditorGUILayoutEx.unityTypes);
//								
//										GUIContent[] objectPropDisplayOptions;
//										UnityVariable[] variables;
//								
//										if (__selectedType != null)
//												Utility.ObjectToDisplayOptionsValues<UnityVariable> (variable.reflectedInstance, __selectedType, out objectPropDisplayOptions, out variables);
//								
//										if (variables != null && variables.Length > 0) {
//									
//												rect.width = 100;
//												rect.xMin += 196f;
//									
//												EditorGUI.BeginChangeCheck ();
//									
//									
//												variable = EditorGUILayoutEx.CustomObjectPopup<UnityVariable> (null,
//									                                                            variable,
//									                                                            objectPropDisplayOptions,
//									                                                            variables.Select (item => item.MemberInfo),
//									                                                            null,
//									                                                            null,
//									                                                            null,
//									                                                            rect
//												);
//									
//									
//									
//									
//												if (EditorGUI.EndChangeCheck ()) {
//										
//											
//												
//												EditorUtility.SetDirty (variable);
//										
//												}
//										}
//						
//								
//
//
//					
//
//						}
//
//
//					
//
//				}
		
				public Rect DrawObjectVar (Rect rect, UnityVariable variable)
				{
						rect.width = Mathf.Max (Screen.width - 50, rect.width);
						rect.height = 21;
						//????/
						rect.yMin = rect.yMin + 3f;
						rect.yMax = rect.yMax - 2f;
						rect.xMin = rect.xMin + 6f;
						rect.xMax = rect.xMax - 6f;
						rect.height = rect.height - 18f;
						EditorGUILayoutEx.DrawName (new Rect (rect.x, rect.y, 80f, rect.height), variable);
						rect.xMin = rect.xMin + 84f;
						rect.xMax = rect.xMax - 19f;
						Type objectType = variable.ValueType;
						EditorGUI.BeginChangeCheck ();
						UnityEngine.Object @object = EditorGUI.ObjectField (rect, GUIContent.none, (UnityEngine.Object)variable.Value, objectType, true);
						if (EditorGUI.EndChangeCheck () && @object != variable.Value) {
								
								Undo.RecordObject (variable, "Variable Value");
								
								variable.Value = @object;

								
								EditorUtility.SetDirty (variable);
								
						}
						rect.y = rect.y + (rect.height + 3f);
						string text = objectType.ToString ();
						if (GUI.Button (rect, text, EditorStyles.popup)) {
								GenericMenu genericMenu = new GenericMenu ();
								genericMenu.AddItem (new GUIContent ("None"), string.IsNullOrEmpty (text), null, typeof(UnityEngine.Object));
								// new GenericMenu.MenuFunction2 (EditorGUILayoutEx.SetObjectType), 
								// new EditorGUILayoutEx.SetObjectVarType (objectVar, typeof(Object)));
								Type[] derivedTypes = TypeUtility.GetDerivedTypes (typeof(UnityEngine.Object));
								for (int i = 0; i < derivedTypes.Length; i++) {
										string text2 = derivedTypes [i].ToString ();
										genericMenu.AddItem (new GUIContent (text2.Replace ('.', '/')), text == text2, null, derivedTypes [i]);
										// new GenericMenu.MenuFunction2 (EditorGUILayoutEx.SetObjectType), 
										// new EditorGUILayoutEx.SetObjectVarType (objectVar, derivedTypes [i]));
								}
								genericMenu.ShowAsContext ();
						}
							
						return rect;
				}
		
				public static Rect DrawQuaternionVar (Rect rect, UnityVariable variable)
				{
						Rect rectOrg = new Rect (rect.x, rect.y, rect.width, rect.height);
			
			
						rect.width = Mathf.Max (Screen.width - 50, rect.width);
						rect.height = 21;
						rect.yMin = rect.yMin + 3f;
						rect.yMax = rect.yMax - 2f;
						rect.xMin = rect.xMin + 6f;
						rect.xMax = rect.xMax - 6f;
						EditorGUILayoutEx.DrawName (new Rect (rect.x, rect.y, 80f, rect.height), variable);
						rect.xMin = rect.xMin + 84f;
						rect.xMax = rect.xMax - 19f;
						rect.y = rect.y - 16f;
						Quaternion value = (Quaternion)variable.Value;
						Vector4 vector = new Vector4 (value.x, value.y, value.z, value.w);
						EditorGUI.BeginChangeCheck ();
						Vector4 vector2 = EditorGUI.Vector4Field (rect, string.Empty, vector);
						if (EditorGUI.EndChangeCheck () && vector != vector2) {

								Undo.RecordObject (variable, "Variable Value");


								variable.Value = new Quaternion (vector2.x, vector2.y, vector2.z, vector2.w);

								EditorUtility.SetDirty (variable);
			
						}


						return rectOrg;
		
		
				}
		
				public static Rect DrawRectVar (Rect rect, UnityVariable variable)
				{
						Rect rectOrg = new Rect (rect.x, rect.y, rect.width, rect.height);
			
						rect.width = Mathf.Max (Screen.width - 50, rect.width);
						rect.height = 21;
						rect.yMin = rect.yMin + 3f;
						rect.yMax = rect.yMax - 2f;
						rect.xMin = rect.xMin + 6f;
						rect.xMax = rect.xMax - 6f;
						EditorGUILayoutEx.DrawName (new Rect (rect.x, rect.y, 80f, rect.height - 18f), variable);
						rect.xMin = rect.xMin + 84f;
						rect.xMax = rect.xMax - 19f;
						EditorGUI.BeginChangeCheck ();
						Rect rect2 = EditorGUI.RectField (rect, GUIContent.none, (Rect)variable.Value);
						if (EditorGUI.EndChangeCheck () && rect2 != (Rect)variable.Value) {

								Undo.RecordObject (variable, "Variable Value");
				
								variable.Value = rect2;

								EditorUtility.SetDirty (variable);

						}

						return rectOrg;

				}
		
				public static Rect DrawStringVar (Rect rect, UnityVariable variable)
				{
						Rect rectOrg = new Rect (rect.x, rect.y, rect.width, rect.height);
			
						rect.width = Mathf.Max (Screen.width - 50, rect.width);
						rect.height = 21;
						rect.yMin = rect.yMin + 3f;
						rect.yMax = rect.yMax - 2f;
						rect.xMin = rect.xMin + 6f;
						rect.xMax = rect.xMax - 6f;
						EditorGUILayoutEx.DrawName (new Rect (rect.x, rect.y, 80f, rect.height), variable);
						rect.xMin = rect.xMin + 124f;
						rect.xMax = rect.xMax - 19f;
						EditorGUI.BeginChangeCheck ();
						string text = EditorGUI.TextField (rect, GUIContent.none, (string)variable.Value);
						if (EditorGUI.EndChangeCheck () && text != (string)variable.Value) {

								Undo.RecordObject (variable, "Variable Value");
				
								variable.Value = text;

								EditorUtility.SetDirty (variable);

						}


						return rectOrg;

				}

		#endregion
		


		}
}