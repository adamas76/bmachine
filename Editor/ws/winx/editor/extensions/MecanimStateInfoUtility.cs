// ------------------------------------------------------------------------------
//  <autogenerated>
//      This code was generated by a tool.
//      Mono Runtime Version: 4.0.30319.1
// 
//      Changes to this file may cause incorrect behavior and will be lost if 
//      the code is regenerated.
//  </autogenerated>
// ------------------------------------------------------------------------------
using System;
using ws.winx.bmachine.extensions;
using UnityEngine;
using System.Collections.Generic;

using ws.winx.unity;


namespace ws.winx.editor.extensions
{
		public class MecanimStateInfoUtility
		{
		
		/// <summary>
		/// Processes the state machine path inside hierarchy.
		/// </summary>
		/// <param name="stateMachine">State machine.</param>
		/// <param name="parentName">Parent name.</param>
		/// <param name="layer">Layer.</param>
		/// <param name="resultsAnimaInfoList">Results anima info list.</param>
		 static void processStateMachinePath (UnityEditor.Animations.AnimatorStateMachine stateMachine, string parentName, int layer, List<MecanimStateInfo> resultsAnimaInfoList)
		{
			int numStates = 0;
			int numStateMachines = 0;
			
			int currentStateInx;
			int currentStateMachineInx;
			UnityEditor.Animations.AnimatorStateMachine currentStateMachine;
			string path;
			
			UnityEditor.Animations.AnimatorState state;
			
			numStates = stateMachine.states.Length;
			
			
			
			for (currentStateInx=0; currentStateInx<numStates; currentStateInx++) {
				
				
				state = stateMachine.states[currentStateInx].state;
		//	resultsAnimaInfoList.Add (new AnimaStateInfo (state.uniqueNameHash, new GUIContent (parentName + '/' + state.name), layer));
//				
				MecanimStateInfo info=ScriptableObject.CreateInstance<MecanimStateInfo>();
				info.hash=state.nameHash;
				info.label= new GUIContent (parentName + '/' + state.name);
				info.layer = layer;
				info.motion=state.motion;

			

				if(info.motion is UnityEditor.Animations.BlendTree){
					UnityEditor.Animations.BlendTree blendTree=info.motion as UnityEditor.Animations.BlendTree;
					int count=blendTree.GetRecursiveBlendParamCount();

					if(count>0){
						info.blendParamsNames=new string[count];
						info.blendParamsIDs=new int[count];

						for (int j = 0; j < count; j++)
						{
							info.blendParamsNames[j]=blendTree.GetRecursiveBlendParam(j);
							info.blendParamsIDs[j]=Animator.StringToHash(info.blendParamsNames[j]);
						}


					}



				}

				resultsAnimaInfoList.Add (info);

				
			}
			
			
			numStateMachines = stateMachine.stateMachines.Length;
			
			if (numStateMachines > 0) {
				for (currentStateMachineInx=0; currentStateMachineInx<numStateMachines; currentStateMachineInx++) {
					currentStateMachine = stateMachine.stateMachines[ currentStateMachineInx].stateMachine;
					path = parentName + "/" + currentStateMachine.name;
					
					processStateMachinePath (currentStateMachine, path, layer, resultsAnimaInfoList);
					
				}
			} else if (numStates == 0) {
				//statesPathStringBuilder.Append (parentName).Append ("(Empty)|");
				//searchList.Add (new AnimaStateInfo(state.uniqueNameHash,new GUIContent (parentName+"(Empty)"),layer));
			}
			
		}
		
		
		/// <summary>
		/// Gets the anima states info.
		/// </summary>
		/// <returns>The anima states info.</returns>
		/// <param name="aniController">Ani controller.</param>
		public static List<MecanimStateInfo> getAnimaStatesInfo (UnityEditor.Animations.AnimatorController aniController)
		{
			
			UnityEditor.Animations.AnimatorControllerLayer layer;
			
			
			int numLayers = aniController.layers.Length;
			
			
			int currentLayerInx = 0;
			
			
			List<MecanimStateInfo> animaStatesInfoList = new List<MecanimStateInfo> ();
			
			
			for (; currentLayerInx<numLayers; currentLayerInx++) {
				layer = aniController.layers [currentLayerInx];				                
				processStateMachinePath (layer.stateMachine, layer.name, currentLayerInx, animaStatesInfoList);	
			}
			
			return animaStatesInfoList;
			
		}
		}
}

