// ------------------------------------------------------------------------------
//  <autogenerated>
//      This code was generated by a tool.
//      Mono Runtime Version: 4.0.30319.1
// 
//      Changes to this file may cause incorrect behavior and will be lost if 
//      the code is regenerated.
//  </autogenerated>
// ------------------------------------------------------------------------------
using System;
using BehaviourMachine;
using BehaviourMachineEditor;
using UnityEditor;
using UnityEngine;
using ws.winx.bmachine.extensions;
using ws.winx.unity;
using UnityEditorInternal;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using ws.winx.editor.extensions;
using System.IO;
using ws.winx.editor.utilities;

namespace ws.winx.editor.bmachine.extensions
{
		public class MecanimNodeEditorWindow:EditorWindow
		{
				private static MecanimNodeEditorWindow __window;
				private static MecanimNode __mecanimNode;
				private static SerializedNode __serializedNode;
				private static ReorderableList __gameObjectClipList;
				private static AvatarPreviewW avatarPreview;
				private static  SerializedNodeProperty curvesSerialized;
				private static	SerializedNodeProperty curvesColorsSerialized;
				private static	SerializedNodeProperty variablesBindedToCurvesSerialized;
				private static	SerializedNodeProperty animatorStateSerialized;
				private static	SerializedNodeProperty animatorStateRuntimeControlEnabledSerialized;
				private static	SerializedNodeProperty animatorStateRunTimeControlSerialized;
				private static	SerializedNodeProperty motionOverrideSerialized;
				private static	SerializedNodeProperty clipBindingsSerialized;
				private static float __timeNormalized;
				private static AnimationCurve[] curves;
				private		static Color[] curveColors;
				private		static UnityVariable[] variablesBindedToCurves;
				private		static string[] curvePropertyDisplayOptions;
				private		static int _curveIndexSelected;
				private		static Color _colorSelected;
				private		static bool _curvesEditorShow;
				private		static CurveEditorW curveEditor;
				private		static GUIContent propertyPopupLabel = new GUIContent (String.Empty);
				private		static Vector2 curvePropertiesScroller;
				private		static UnityVariable __variableSelected;
				private static bool __isPlaying;
				private static bool __isRecording;
				private static float __timeCurrent;//in [seconds]
				private static EditorClipBinding __nodeClipBinding;
				private static EditorClipBinding[] __clipBindingsToBeAnimated;
				private static bool __timeNormalizedUpdate;

				public static void Show (MecanimNode target, SerializedNode node, Rect? position)
				{
						MecanimNodeEditorWindow.__mecanimNode = target;

						MecanimNodeEditorWindow.__serializedNode = node;


						

						///////   ACCESS SERIALIZED DATA /////////
						NodePropertyIterator iterator = node.GetIterator ();

						__isPlaying = false;
						__isRecording = false;
						__variableSelected = null;
						__timeNormalized = 0f;
						__timeNormalizedUpdate = false;
						__timeCurrent = 0f;
						AnimationMode.StopAnimationMode ();
						Undo.postprocessModifications -= PostprocessAnimationRecordingModifications;

						SceneView.onSceneGUIDelegate += OnSceneGUI;


						if (iterator.Find ("animatorStateSelected"))
								animatorStateSerialized = iterator.current;
			
			
						if (iterator.Find ("motionOverride"))
								motionOverrideSerialized = iterator.current;

						if (iterator.Find ("clipBindings"))
								clipBindingsSerialized = iterator.current;



			
						if (__nodeClipBinding == null)
								__nodeClipBinding = ScriptableObject.CreateInstance<EditorClipBinding> ();
						
						__nodeClipBinding.gameObject = target.self;
						__nodeClipBinding.clip = getNodeClip ();
						

						

						/////// INIT SERIALIZED NODE PROPERTIES - CURVES, COLORS, VARIABLES //////
						
							
						if (iterator.Find ("curves"))
								curvesSerialized = iterator.current;
						else
								Debug.LogError ("MecananimNode should have public field 'curves'");
							
						if (iterator.Find ("curvesColors"))
								curvesColorsSerialized = iterator.current;
						else
								Debug.LogError ("MecananimNode should have public field 'curvesColors'");
							
						if (iterator.Find ("variablesBindedToCurves")) 
								variablesBindedToCurvesSerialized = iterator.current;
						else
								Debug.LogError ("MecananimNode should have public field 'variablesBindedToCurves'");
		
							
							
							
						curves = (AnimationCurve[])curvesSerialized.value;
						curveColors = (Color[])curvesColorsSerialized.value;
						variablesBindedToCurves = (UnityVariable[])variablesBindedToCurvesSerialized.value;
						
						AnimationModeUtility.ResetBindingsTransformPropertyModification (clipBindingsSerialized.value as EditorClipBinding[]);
						AnimationModeUtility.ResetBindingTransformPropertyModification (__nodeClipBinding);

						

						
						

						//create Reordable list of gameObject-animationClip

						__gameObjectClipList = new ReorderableList (clipBindingsSerialized.value as IList, typeof(EditorClipBinding), true, true, true, true);
						__gameObjectClipList.drawElementCallback = onDrawElement;
									
						
									
						__gameObjectClipList.drawHeaderCallback = onDrawHeaderElement;
									
						__gameObjectClipList.onRemoveCallback = onRemoveCallback;
						__gameObjectClipList.onAddCallback = onAddCallback;
						__gameObjectClipList.onSelectCallback = onSelectCallback;
						
									
						//__gameObjectClipList.elementHeight = 32f;                                    
			                                                              
			                                                              
						if (MecanimNodeEditorWindow.__window != null)//restore last 
								position = __window.position;

		
						MecanimNodeEditorWindow.__window = (MecanimNodeEditorWindow)EditorWindow.GetWindow (typeof(MecanimNodeEditorWindow));


						 
						if (position.HasValue)
								MecanimNodeEditorWindow.__window.position = position.Value;
						MecanimNodeEditorWindow.__window.Show ();
				}

				public static void Hide ()
				{
						if (__window != null)
								__window.Close ();
				}


				/// <summary>
				/// Ons the curve select.
				/// </summary>
				/// <param name="index">Index.</param>
				private static void onCurveSelect (int index)
				{
						Debug.Log ("Curve " + index + " selected");
					
						_curveIndexSelected = index;
					
					
					
				}


				/// <summary>
				/// Raises the scene GUI event.
				/// </summary>
				/// <param name="sceneView">Scene view.</param>
				private static void OnSceneGUI (SceneView sceneView)
				{
					if (clipBindingsSerialized.value == null) return;

			EditorClipBinding[] clipBindings = clipBindingsSerialized.value as EditorClipBinding[];
						int bindingsLength=clipBindings.Length;
						Color clr = Color.red;
						Vector3[] positionsInKeyframe = null;
						AnimationClip clip = null;
						
						EditorClipBinding clipBindingCurrent = null;

						long indexListAndindexFramePacked = 0;

						Transform transformRoot = null;

						
						
				

						for (int i=0; i<bindingsLength; i++) {

								clipBindingCurrent = clipBindings[i];

								if (clipBindingCurrent.visible) {
									
										
										clip = clipBindingCurrent.clip;

										if (clip != null && clipBindingCurrent.gameObject != null) {

												
											
												
												if(!clipBindingCurrent.gameObject.isRoot())
												{
														transformRoot = clipBindingCurrent.gameObject.transform.root;

														//save
														
														UnityClipboard.CopyTransform(transformRoot);

														//rewind to start position
														transformRoot.position = clipBindingCurrent.positionOriginalRoot;
														transformRoot.rotation = clipBindingCurrent.rotationOriginalRoot;

														positionsInKeyframe = AnimationUtilityEx.GetPositions (clip, transformRoot);

														//restore saved
														UnityClipboard.PasteTransform(ref transformRoot);
														
												}else{

													positionsInKeyframe = AnimationUtilityEx.GetPositions (clip);

												}
												

												if (positionsInKeyframe != null) {			
														for (int j=0; j<positionsInKeyframe.Length; j++) {

																indexListAndindexFramePacked = i;//put index of clipBinding in list/array
																indexListAndindexFramePacked = indexListAndindexFramePacked << 32 | (uint)j;

																//actualy this is static handle
																 HandlesEx.DragHandle (positionsInKeyframe [j], 0.1f, Handles.SphereCap, Color.red, "("+j+")"+" "+AnimationUtilityEx.GetTimeAt(clip,j), indexListAndindexFramePacked, onDragHandleEvent, new GUIContent[]{new GUIContent ("Delete")}, new long[]{j}, null);
							


														}
														//save color
														clr = Handles.color;

														
														clipBindingCurrent.color.a = 1;
														Handles.color = clipBindingCurrent.color;


														Handles.DrawPolyLine (positionsInKeyframe);
														//restore color
														Handles.color = clr;
												}

												
										}
								}
						}
					

						//Debug.Log ("hot"+GUIUtility.hotControl);
					
						SceneView.RepaintAll ();
				}


				/// <summary>
				/// Ons the DragHandle event.
				/// </summary>
				/// <param name="controlID">Control I.</param>
				/// <param name="e">E.</param>
				/// <param name="userData">User data.</param>
				private static void onDragHandleEvent (int controlID, Event e, long userData)
				{
						if (e.type == EventType.KeyDown && e.keyCode == KeyCode.Delete) {
								int bindingInx = (int)(userData >> 32);
								int keyframeInx = (int)userData;

								
								EditorClipBinding[] clipBindings = (clipBindingsSerialized.value as EditorClipBinding[]);
								AnimationClip clip = clipBindings [bindingInx].clip;
								AnimationUtilityEx.RemovePositionAt (clip, keyframeInx);
								

						} else if (e.type == EventType.MouseDown && e.button == 0 && e.clickCount == 1) {
								int bindingInx = (int)(userData >> 32);
								int keyframeInx = (int)(userData & 0x0000FFFF);
								EditorClipBinding[] clipBindings = (clipBindingsSerialized.value as EditorClipBinding[]);
								AnimationClip clip = clipBindings [bindingInx].clip;


								Debug.Log ("bind:" + bindingInx + " " + keyframeInx);

								//get curve 
								//				
								float timeAtKeyframe = AnimationUtility.GetEditorCurve (clip, EditorCurveBinding.FloatCurve ("", typeof(Transform), "m_LocalPosition.x")).keys [keyframeInx].time;
								__timeNormalized = timeAtKeyframe * 1f / getNodeClip ().length;
								__timeNormalizedUpdate = true;
				                
								__window.Repaint ();
						}

				}


//				// Custom Gizmos, Create as many as you'd like
//				[DrawGizmo(GizmoType.NotSelected | GizmoType.Selected)]
//				private static void DrawGizmo (Transform aTarget, GizmoType aGizmoType)
//				{
//
//						if (__gameObjectClipList == null)
//								return;
//
//						int gameObjectCount = __gameObjectClipList.count;
//
//						Vector3[] gameObjectPositionsInTime = null;
//						Vector3 cubeSize = new Vector3 (0.1f, 0.1f, 0.1f);
//						AnimationClip clip = null;
//						Color clr = Color.green;
//			
//						for (int i=0; i<gameObjectCount; i++) {
//
//								clip = (__gameObjectClipList.list [i] as EditorClipBinding).clip;
//
//								if (clip != null) {
//										gameObjectPositionsInTime = AnimationUtilityEx.GetPositions (clip);
//				
//										clr = Gizmos.color;
//			
//
//										Gizmos.color = Color.green;
//
//										for (int j=0; j<gameObjectPositionsInTime.Length; j++)
//												Gizmos.DrawCube (gameObjectPositionsInTime [j], cubeSize);
//
//										Gizmos.color = clr;
//
//								}
//						}
//				}


				/// <summary>
				/// Postprocesses the animation recording and property modifications.
				/// </summary>
				/// <returns>The animation recording modifications.</returns>
				/// <param name="modifications">Modifications.</param>
				private static UndoPropertyModification[] PostprocessAnimationRecordingModifications (UndoPropertyModification[] modifications)
				{
						List<UndoPropertyModification> propertyModificationList = new List<UndoPropertyModification> ();
						EditorClipBinding[] clipBindings = clipBindingsSerialized.value as EditorClipBinding[];

						Array.ForEach (clipBindings, (itm) => {

								propertyModificationList.Concat (AnimationModeUtility.Process (itm.gameObject, itm.clip, modifications, __timeCurrent));


						});


						return propertyModificationList.ToArray ();
				}


			
				////////////////// GAMEOBJECT - CLIP LIST EVENTS //////////////////
				
		
				private static void onRemoveCallback (ReorderableList list)
				{
						if (UnityEditor.EditorUtility.DisplayDialog ("Warning!", 
			                                             "Are you sure you want to delete the Unity Variable?", "Yes", "No")) {
								List<EditorClipBinding> bindingList = ((EditorClipBinding[])clipBindingsSerialized.value).ToList ();
								bindingList.RemoveAt (list.index);

								clipBindingsSerialized.value = bindingList.ToArray ();
								clipBindingsSerialized.ApplyModifiedValue ();
				
								list.list = clipBindingsSerialized.value as IList;
				

				
						}
				}

				private static void onAddCallback (ReorderableList list)
				{
						List<EditorClipBinding> bindingList = ((EditorClipBinding[])clipBindingsSerialized.value).ToList ();


						bindingList.Add (ScriptableObject.CreateInstance<EditorClipBinding> ());

						clipBindingsSerialized.value = bindingList.ToArray ();
						clipBindingsSerialized.ApplyModifiedValue ();

						list.list = clipBindingsSerialized.value as IList;
						
				}
		
				private static void onDrawElement (Rect rect, int index, bool isActive, bool isFocused)
				{
			



						EditorClipBinding clipBindingCurrent = __gameObjectClipList.list [index] as EditorClipBinding;
			
						if (clipBindingCurrent == null) {
								return;
						}

						

						float width = rect.xMax;
						
						rect.xMax = 200f;

						

						EditorGUI.BeginChangeCheck ();

						GameObject gameObjectBinded = EditorGUI.ObjectField (rect, clipBindingCurrent.gameObject, typeof(GameObject), true) as GameObject;

						if (EditorGUI.EndChangeCheck () && gameObjectBinded != null) {	

								clipBindingCurrent.gameObject = gameObjectBinded;
								
								
								
						}



						rect.xMin = rect.xMax + 2;
						rect.xMax = width - 100f;


						

						clipBindingCurrent.clip = EditorGUI.ObjectField (rect, clipBindingCurrent.clip, typeof(AnimationClip), true) as AnimationClip;

						if (clipBindingCurrent.clip == null) {

								rect.xMin = rect.xMax + 2;
								rect.xMax = rect.xMin + 30f;

								if (GUI.Button (rect, "New Clip")) {

										string path = EditorUtility.SaveFilePanel (
										"Create New Clip",
										"Assets",
										"",
										"anim");
										
										if (!String.IsNullOrEmpty (path)) {
											
												AnimationClip clip = new AnimationClip ();//UnityEditor.Animations.AnimatorController.AllocateAnimatorClip ();
												clip.name = Path.GetFileNameWithoutExtension (path);		
												AssetDatabase.CreateAsset (clip, AssetDatabaseUtility.AbsoluteUrlToAssets (path));
												AssetDatabase.SaveAssets ();
												clipBindingCurrent.clip = clip;

										}
								}
						}

						rect.xMin = rect.xMax + 2f;
						rect.xMax = rect.xMin + 30f;
						clipBindingCurrent.color = EditorGUI.ColorField (rect, clipBindingCurrent.color);

						rect.xMin = rect.xMax + 2f;
						rect.xMax = width;
						clipBindingCurrent.visible = EditorGUI.Toggle (rect, clipBindingCurrent.visible);
			
				}
		
				static void onDrawHeaderElement (Rect rect)
				{
						EditorGUI.LabelField (rect, "GameObject - AnimationClips:");
				}

				static void onSelectCallback (ReorderableList list)
				{

						Selection.activeGameObject = (list.list as EditorClipBinding[]) [list.index].gameObject;
				}

				/// /////////////////////////////////////////////////////////////////////


				
				/// <summary>
				/// Gets the MecanimNode clip.
				/// </summary>
				/// <returns>The node clip.</returns>
				static AnimationClip getNodeClip ()
				{
						//////////  MOTION OVERRIDE HANDLING  //////////
			
						UnityEngine.Motion motion = null;
			
						UnityVariable motionOverridVariable = (UnityVariable)motionOverrideSerialized.value;
			
						//if there are no override use motion of selected AnimationState
						//Debug.Log(((UnityEngine.Object)mecanimNode.motionOverride.Value).);
						if (motionOverridVariable == null || motionOverridVariable.Value == null || motionOverridVariable.ValueType != typeof(AnimationClip))
								motion = ((ws.winx.unity.AnimatorState)animatorStateSerialized.value).motion;
						else //
								motion = (UnityEngine.Motion)motionOverridVariable.Value;
			
			
			
						if (motionOverridVariable != null && motionOverridVariable.Value != null && ((ws.winx.unity.AnimatorState)animatorStateSerialized.value).motion == null) {
								Debug.LogError ("Can't override state that doesn't contain motion");
						}

						return motion as AnimationClip;

				}

				
				/// <summary>
				/// Raises the GUI event.
				/// </summary>
				void OnGUI ()
				{


			
						if (!Application.isPlaying && __mecanimNode != null && animatorStateSerialized.value != null) {



								_curvesEditorShow = EditorGUILayout.Foldout (_curvesEditorShow, "Curves");
				
								//int indentLevel = 0;
				
								Rect curveEditorRect = new Rect (0, 0, 0, 0);
								int i = 0;

				
								if (_curvesEditorShow) {
					

					
										//This makes layout to work (Reserving space)
										curveEditorRect = GUILayoutUtility.GetRect (Screen.width - 16f, 200);
					
										/////// CURVE EDITOR ////////
										curveEditorRect.width = curveEditorRect.width - 32f;
										curveEditorRect.x = 16f;
					
					
										if (curveEditor == null) {
						
												CurveWrapperW[] curveWrappers;
						
												int numCurves = curves.Length;
						
												curveWrappers = new CurveWrapperW[numCurves];
						
												CurveWrapperW curveWrapperNew;
						
												for (i=0; i<numCurves; i++) {
														curveWrapperNew = new CurveWrapperW ();
														curveWrapperNew.curve = curves [i];
														curveWrapperNew.color = curveColors [i];
														curveWrappers [i] = curveWrapperNew;
												}
						
						
						
												curveEditor = new CurveEditorW (curveEditorRect, curveWrappers, false);
						
												curveEditor.FrameSelected (true, true);
												curveEditor.scaleWithWindow = true;
												curveEditor.hSlider = false;
												curveEditor.hRangeMin = 0f;
												curveEditor.hRangeMax = 1f;
												curveEditor.hRangeLocked = true;
						
												curveEditor.onSelect += onCurveSelect;
						
						
						
						
										} else {
						
												curveEditor.rect = curveEditorRect;
												curveEditor.FrameSelected (false, false);
						
										}
					
					
					
										curveEditor.DoEditor ();
					
					
					
										///////////////////////////////////////////////////////////////////////////////
					
					
					
					
					
										/////////////   ADD/REMOVE CURVE BINDED TO OBJECT PROP OR GLOBAL VARIABLE /////////////
										///                                                                                  //

										EditorGUILayout.BeginHorizontal ();
					
					
					
					
										//if curve is selected display curve properties
										if (_curveIndexSelected > -1 && _curveIndexSelected < variablesBindedToCurves.Length) {
						
												UnityVariable variableSelected = variablesBindedToCurves [_curveIndexSelected];
						
						
												EditorGUILayout.LabelField (variableSelected.name, new GUILayoutOption[]{});
						
												EditorGUI.BeginChangeCheck ();
												Color colorNew = EditorGUILayout.ColorField (curveColors [_curveIndexSelected]);
						
						
												if (EditorGUI.EndChangeCheck ()) {
														curveEditor.animationCurves [_curveIndexSelected].color = colorNew;
														curveColors [_curveIndexSelected] = colorNew;
														curvesColorsSerialized.ValueChanged ();
														curvesColorsSerialized.ApplyModifiedValue ();
							
							
												}
						
										} else {
						
						
						
												propertyPopupLabel.text = "Select blackboard var";
						
						
												List<UnityVariable> blackboardLocalList = __mecanimNode.blackboard.GetVariableBy (typeof(float));
						
												List<GUIContent> displayOptionsList = blackboardLocalList.Select ((item) => new GUIContent ("Local/" + item.name)).ToList ();
						
						
						
						
												__variableSelected = EditorGUILayoutEx.UnityVariablePopup (new GUIContent ("Var:"), __variableSelected, typeof(float), displayOptionsList, blackboardLocalList);
						
						
						
						
						
						
												_colorSelected = EditorGUILayout.ColorField (_colorSelected);
						
										}
					
					
					
					
					
										/////////////// ADD CURVE(+) /////////
										if (GUILayout.Button ("Add") && __variableSelected != null) {
						
						
						
						
												List<UnityVariable> vList = variablesBindedToCurves.ToList ();
												vList.Add (__variableSelected);
												variablesBindedToCurvesSerialized.value = variablesBindedToCurves = vList.ToArray ();
												variablesBindedToCurvesSerialized.ValueChanged ();
												//variablesBindedToCurvesSerialized.ApplyModifiedValue ();
						
						
						
						
						
						
												List<Color> cList = curveColors.ToList ();
												_colorSelected.a = 1;
												cList.Add (_colorSelected);
												curvesColorsSerialized.value = curveColors = cList.ToArray ();
												curvesColorsSerialized.ValueChanged ();	
												//curvesColorsSerialized.ApplyModifiedValue ();		
						
						
						
						
						
						
												AnimationCurve curveAnimationNew;
						
						
						
												List<AnimationCurve> crList = curves.ToList ();
						
												curveAnimationNew = new AnimationCurve (new Keyframe[] {
							new Keyframe (0f, (float)__variableSelected.Value),
							new Keyframe (1f, 1f)
						});
						
												//TODO add from preset
												crList.Add (curveAnimationNew);
						
												curvesSerialized.value = curves = crList.ToArray ();
												curvesSerialized.ValueChanged ();
												//curvesColorsSerialized.ApplyModifiedValue ();
						
						
						
												///add curve wrapped to CurveEditor
												CurveWrapperW curveWrapperW = new CurveWrapperW ();
						
												curveWrapperW.color = _colorSelected;
						
												curveWrapperW.curve = curveAnimationNew;
						
												curveEditor.AddCurve (curveWrapperW);
						
												curveEditor.FrameSelected (true, true);
						
						
						
												__serializedNode.Update ();
						
												__serializedNode.ApplyModifiedProperties ();
						
						
												__variableSelected = null;
						
										}



										/// DELETE CURVE ///
										if (GUILayout.Button ("Del") || Event.current.keyCode == KeyCode.Delete) {
						
						
												curveEditor.RemoveCurveAt (_curveIndexSelected);
						
						
						
												List<UnityVariable> vList = variablesBindedToCurves.ToList ();
												vList.RemoveAt (_curveIndexSelected);
												variablesBindedToCurvesSerialized.value = variablesBindedToCurves = vList.ToArray ();
												variablesBindedToCurvesSerialized.ValueChanged ();
						
						
						
						
						
												List<Color> cList = curveColors.ToList ();
						
												cList.RemoveAt (_curveIndexSelected);
												curvesColorsSerialized.value = curveColors = cList.ToArray ();
												curvesColorsSerialized.ValueChanged ();
						
						
						
						
						
												List<AnimationCurve> crList = curves.ToList ();
						
												crList.RemoveAt (_curveIndexSelected);
						
												curvesSerialized.value = curves = crList.ToArray ();
												curvesSerialized.ValueChanged ();
						
						
						
						
												_curveIndexSelected = -1;
												__variableSelected = null;
						
												__serializedNode.ApplyModifiedProperties ();
						
						
										}
					
					
					
				
					
					
										EditorGUILayout.EndHorizontal ();



				


								} else {//NOT CURVE EDITOR



										///////////// GAMEOBJECT - CLIP BINDINGS //////////
								
										__gameObjectClipList.DoLayoutList ();


										//////////////////////////////////////////////

								}



								EditorGUILayout.Space ();



								__nodeClipBinding.clip = getNodeClip ();


								/////////////   TIME CONTROL OF ANIMATION (SLIDER) /////////
					
								Rect timeControlRect = GUILayoutUtility.GetRect (Screen.width, 26f);

								
							

								timeControlRect.xMax = 32f;

							


								__isPlaying = GUI.Toggle (timeControlRect, __isPlaying, !__isPlaying ? TimeControlW.style.playIcon : TimeControlW.style.pauseIcon, TimeControlW.style.playButton);


								if (__isPlaying) {
					
					
					
								} else {
					
					
					
								}		


								timeControlRect.xMin = timeControlRect.xMax + 1f;
								timeControlRect.xMax = timeControlRect.xMin + 21f;
								timeControlRect.yMin += 2f;


								EditorGUI.BeginChangeCheck ();

								Color color = GUI.color;


								if (AnimationMode.InAnimationMode ())
										GUI.color = AnimationMode.animatedPropertyColor;//change color of record button to red

								__isRecording = GUI.Toggle (timeControlRect, __isRecording, TimeControlW.style.recordIcon, EditorStyles.toolbarButton);

								GUI.color = color;

								if (EditorGUI.EndChangeCheck ())
								if (__isRecording) {
						




										if (!AnimationMode.InAnimationMode ()) {


												List<EditorClipBinding> list = (clipBindingsSerialized.value as EditorClipBinding[]).ToList ();
												list.Add (__nodeClipBinding);

												__clipBindingsToBeAnimated = list.ToArray ();
												
												AnimationMode.StartAnimationMode ();
												Undo.postprocessModifications += PostprocessAnimationRecordingModifications;

												

												//calculate offset of boonRoot position before animation from boonRoot position at time=0s.
												AnimationModeUtility.SaveBindingsOffset (clipBindingsSerialized.value as EditorClipBinding[]);

												AnimationModeUtility.SaveBindingStatus(__nodeClipBinding);
												
												//calculate time in seconds from the current postion of time scrubber
												__timeCurrent = __timeNormalized * getNodeClip ().length;

												//apply clip animaiton at __timeCurrent
												AnimationModeUtility.SampleClipBindingAt (__clipBindingsToBeAnimated
						                                        , __timeCurrent);

												

												SceneView.RepaintAll ();
										}
									
										
						
								} else {
										//Remove Undo property modificaiton handlers
										Undo.postprocessModifications -= PostprocessAnimationRecordingModifications;

										AnimationMode.StopAnimationMode ();

										//reset gameobject with bones to state before animation
										AnimationModeUtility.ResetBindingsTransformPropertyModification (clipBindingsSerialized.value as EditorClipBinding[]);

										//reset Node.self gameObject
										AnimationModeUtility.ResetBindingTransformPropertyModification (__nodeClipBinding);
												
										
						
								}

								timeControlRect.xMin = 40f + 16f;
								timeControlRect.xMax = Screen.width - 68f;
								timeControlRect.yMin -= 2f;



								EditorGUI.BeginChangeCheck ();

								__timeNormalized = EditorGUILayoutEx.CustomHSlider (timeControlRect, __timeNormalized, 0f, 1f, TimeControlW.style.timeScrubber);

								

								
								if (EditorGUI.EndChangeCheck () || __timeNormalizedUpdate) {
					
										__timeCurrent = __timeNormalized * getNodeClip ().length;

										__timeNormalizedUpdate = false;
									
										
										if (!AnimationMode.InAnimationMode ()) {
												AnimationMode.StartAnimationMode ();

												//calculate offset of boonRoot position before animation from boonRoot position at time=0s.
												AnimationModeUtility.SaveBindingsOffset (clipBindingsSerialized.value as EditorClipBinding[]);

												AnimationModeUtility.SaveBindingStatus (__nodeClipBinding);

										}

										if (!__isRecording) {
												__isRecording = true;	

												//add recording Undo events handlers
												Undo.postprocessModifications += PostprocessAnimationRecordingModifications;

												List<EditorClipBinding> list = (clipBindingsSerialized.value as EditorClipBinding[]).ToList ();
												list.Add (__nodeClipBinding);
						
												__clipBindingsToBeAnimated = list.ToArray ();

												
										}
									

								
										//this moves clip binded to gameObject to _timeCurrent
										AnimationModeUtility.SampleClipBindingAt (__clipBindingsToBeAnimated, __timeCurrent);

							


									


								}









								///////////////////////////////////////////////////////////////



								//////////////////////////////////////////////////////////////
								/// 
								///			 Draw red time scrubber line on top of Curve Editor 
								///
								//////////////////////////////////////////////////////////////
				
								if (_curvesEditorShow) {
										Handles.color = Color.red;
				
				
				
										float leftrightMargin = 39f;// 40f;
										float effectiveWidth = curveEditorRect.width - 2 * leftrightMargin - curveEditorRect.xMin;
										float timeLineX = curveEditorRect.xMin + leftrightMargin + effectiveWidth * __timeNormalized;
				
										Handles.DrawLine (new Vector2 (timeLineX, curveEditorRect.y), new Vector2 (timeLineX, curveEditorRect.y + curveEditorRect.height));
								}

					
					
					
								////////// EVALUTE CURVES //////////
								int variablesNum = variablesBindedToCurves.Length;
								for (int varriableCurrentinx=0; varriableCurrentinx<variablesNum; varriableCurrentinx++) {
						
						
										variablesBindedToCurves [varriableCurrentinx].Value = curves [varriableCurrentinx].Evaluate (__timeNormalized);
								}
					
					

					
					
					
						}				
				
				
				
				
				

						

				
				}

				void OnDestroy ()
				{
				
						SceneView.onSceneGUIDelegate -= OnSceneGUI;
						Undo.postprocessModifications -= PostprocessAnimationRecordingModifications;
				
				}

				

		}



		
}

