// ------------------------------------------------------------------------------
//  <autogenerated>
//      This code was generated by a tool.
//      Mono Runtime Version: 4.0.30319.1
// 
//      Changes to this file may cause incorrect behavior and will be lost if 
//      the code is regenerated.
//  </autogenerated>
// ------------------------------------------------------------------------------
using System;
using BehaviourMachine;
using BehaviourMachineEditor;
using UnityEditor;
using UnityEngine;
using ws.winx.bmachine.extensions;
using ws.winx.unity;
using UnityEditorInternal;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using ws.winx.editor.extensions;

namespace ws.winx.editor.bmachine.extensions
{
		public class MecanimNodeEditorWindow:EditorWindow
		{
				private static MecanimNodeEditorWindow window;
				private static MecanimNode __mecanimNode;
				private static SerializedNode __serializedNode;
				private static ReorderableList __gameObjectClipList;
				private static AvatarPreviewW avatarPreview;
				private static  SerializedNodeProperty curvesSerialized;
				private static	SerializedNodeProperty curvesColorsSerialized;
				private static	SerializedNodeProperty variablesBindedToCurvesSerialized;
				private static	SerializedNodeProperty animatorStateSerialized;
				private static	SerializedNodeProperty animatorStateRuntimeControlEnabledSerialized;
				private static	SerializedNodeProperty animatorStateRunTimeControlSerialized;
				private static	SerializedNodeProperty motionOverrideSerialized;
				private static	SerializedNodeProperty clipBindingsSerialized;
				private static float timeNormalized;
				private static AnimationCurve[] curves;
				private		static Color[] curveColors;
				private		static UnityVariable[] variablesBindedToCurves;
				private		static string[] curvePropertyDisplayOptions;
				private		static int _curveIndexSelected;
				private		static Color _colorSelected;
				private		static bool _curvesEditorShow;
				private		static CurveEditorW curveEditor;
				private		static GUIContent propertyPopupLabel = new GUIContent (String.Empty);
				private		static Vector2 curvePropertiesScroller;
				private		static UnityVariable _variableSelected;
				private static bool __isPlaying;
				private static bool __isRecording;

				public static void Show (MecanimNode target, SerializedNode node, Rect? position)
				{
						MecanimNodeEditorWindow.__mecanimNode = target;

						MecanimNodeEditorWindow.__serializedNode = node;
						

						///////   ACCESS SERIALIZED DATA /////////
						NodePropertyIterator iterator = node.GetIterator ();




						if (iterator.Find ("animatorStateSelected"))
								animatorStateSerialized = iterator.current;
			
			
						if (iterator.Find ("motionOverride"))
								motionOverrideSerialized = iterator.current;

						if (iterator.Find ("clipBindings"))
								clipBindingsSerialized = iterator.current;


						/////// INIT SERIALIZED NODE PROPERTIES - CURVES, COLORS, VARIABLES //////
						
							
						if (iterator.Find ("curves"))
								curvesSerialized = iterator.current;
						else
								Debug.LogError ("MecananimNode should have public field 'curves'");
							
						if (iterator.Find ("curvesColors"))
								curvesColorsSerialized = iterator.current;
						else
								Debug.LogError ("MecananimNode should have public field 'curvesColors'");
							
						if (iterator.Find ("variablesBindedToCurves")) 
								variablesBindedToCurvesSerialized = iterator.current;
						else
								Debug.LogError ("MecananimNode should have public field 'variablesBindedToCurves'");
							
							
							
						curves = (AnimationCurve[])curvesSerialized.value;
						curveColors = (Color[])curvesColorsSerialized.value;
						variablesBindedToCurves = (UnityVariable[])variablesBindedToCurvesSerialized.value;
						
					
			//List<EditorClipBinding> listBind=((EditorClipBinding[])clipBindingsSerialized.value).ToList();

			__gameObjectClipList = new ReorderableList ( clipBindingsSerialized.value as IList, typeof(EditorClipBinding),true,true,true,true);
						__gameObjectClipList.drawElementCallback = onDrawElement;
									
						
									
						__gameObjectClipList.drawHeaderCallback = onDrawHeaderElement;
									
						__gameObjectClipList.onRemoveCallback = onRemoveCallback;
						__gameObjectClipList.onAddCallback = onAddCallback;
						
									
						__gameObjectClipList.elementHeight = 32f;                                    
			                                                              
			                                                              
						if (MecanimNodeEditorWindow.window != null)//restore last 
								position = window.position;

		
						MecanimNodeEditorWindow.window = (MecanimNodeEditorWindow)EditorWindow.GetWindow (typeof(MecanimNodeEditorWindow));


						 
						if (position.HasValue)
								MecanimNodeEditorWindow.window.position = position.Value;
						MecanimNodeEditorWindow.window.Show ();
				}

				public static void Hide ()
				{
						if (window != null)
								window.Close ();
				}


				/// <summary>
				/// Ons the curve select.
				/// </summary>
				/// <param name="index">Index.</param>
				void onCurveSelect (int index)
				{
						Debug.Log ("Curve " + index + " selected");
					
						_curveIndexSelected = index;
					
					
					
				}


			
				////////////////// GAMEOBJECT - CLIP LIST EVENTS //////////////////
				
		
				static void onRemoveCallback (ReorderableList list)
				{
						if (UnityEditor.EditorUtility.DisplayDialog ("Warning!", 
			                                             "Are you sure you want to delete the Unity Variable?", "Yes", "No")) {
								ReorderableList.defaultBehaviours.DoRemoveButton (list);
				
								list.serializedProperty.DeleteArrayElementAtIndex (list.index);
				
				

				
						}
				}

					static void onAddCallback (ReorderableList list)
					{
						List<EditorClipBinding> bindingList=((EditorClipBinding[])list.list).ToList ();


						bindingList.Add (ScriptableObject.CreateInstance<EditorClipBinding> ());
						list.list = bindingList.ToArray ();
						
					}
		
				static void onDrawElement (Rect rect, int index, bool isActive, bool isFocused)
				{
			
//						SerializedProperty property = __gameObjectClipList.serializedProperty.GetArrayElementAtIndex (index); 
//			
//						if (property == null || property.objectReferenceValue == null) {
//								return;
//						}


			EditorClipBinding clipBindingCurrent = __gameObjectClipList.list [index] as EditorClipBinding;
			
			if (clipBindingCurrent==null) {
				return;
			}

						

						Rect gameObjectRect = rect;
						Rect clipRect = rect; 

						gameObjectRect.xMax = 40f;

						clipBindingCurrent.gameObject = EditorGUI.ObjectField (gameObjectRect, "Bind", clipBindingCurrent.gameObject, typeof(GameObject), true) as GameObject;

						clipBindingCurrent.clip = EditorGUI.ObjectField (clipRect, "To", clipBindingCurrent.clip, typeof(AnimationClip), true) as AnimationClip;

						if (clipBindingCurrent.clip != null) {

								if (GUILayout.Button ("Create")) {
										clipBindingCurrent.clip = UnityEditor.Animations.AnimatorController.AllocateAnimatorClip ("New Animation");
								}
						}
			
				}
		
				static void onDrawHeaderElement (Rect rect)
				{
						EditorGUI.LabelField (rect, "GameObject - AnimationClips:");
				}



				/// /////////////////////////////////////////////////////////////////////

				

				void OnGUI ()
				{


			
						if (!Application.isPlaying && __mecanimNode != null && animatorStateSerialized.value != null) {



								_curvesEditorShow = EditorGUILayout.Foldout (_curvesEditorShow, "Curves");
				
								//int indentLevel = 0;
				
								Rect curveEditorRect = new Rect (0, 0, 0, 0);
								int i = 0;

				
								if (_curvesEditorShow) {
					

					
										//This makes layout to work (Reserving space)
										curveEditorRect = GUILayoutUtility.GetRect (Screen.width - 16f, 200);
					
										/////// CURVE EDITOR ////////
										curveEditorRect.width = curveEditorRect.width - 32f;
										curveEditorRect.x = 16f;
					
					
										if (curveEditor == null) {
						
												CurveWrapperW[] curveWrappers;
						
												int numCurves = curves.Length;
						
												curveWrappers = new CurveWrapperW[numCurves];
						
												CurveWrapperW curveWrapperNew;
						
												for (i=0; i<numCurves; i++) {
														curveWrapperNew = new CurveWrapperW ();
														curveWrapperNew.curve = curves [i];
														curveWrapperNew.color = curveColors [i];
														curveWrappers [i] = curveWrapperNew;
												}
						
						
						
												curveEditor = new CurveEditorW (curveEditorRect, curveWrappers, false);
						
												curveEditor.FrameSelected (true, true);
												curveEditor.scaleWithWindow = true;
												curveEditor.hSlider = false;
												curveEditor.hRangeMin = 0f;
												curveEditor.hRangeMax = 1f;
												curveEditor.hRangeLocked = true;
						
												curveEditor.onSelect += onCurveSelect;
						
						
						
						
										} else {
						
												curveEditor.rect = curveEditorRect;
												curveEditor.FrameSelected (false, false);
						
										}
					
					
					
										curveEditor.DoEditor ();
					
					
					
										///////////////////////////////////////////////////////////////////////////////
					
					
					
					
					
										/////////////   ADD/REMOVE CURVE BINDED TO OBJECT PROP OR GLOBAL VARIABLE /////////////
										EditorGUILayout.BeginHorizontal ();
					
					
					
					
										//if curve is selected display curve properties
										if (_curveIndexSelected > -1 && _curveIndexSelected < variablesBindedToCurves.Length) {
						
												UnityVariable variableSelected = variablesBindedToCurves [_curveIndexSelected];
						
						
												EditorGUILayout.LabelField (variableSelected.name, new GUILayoutOption[]{});
						
												EditorGUI.BeginChangeCheck ();
												Color colorNew = EditorGUILayout.ColorField (curveColors [_curveIndexSelected]);
						
						
												if (EditorGUI.EndChangeCheck ()) {
														curveEditor.animationCurves [_curveIndexSelected].color = colorNew;
														curveColors [_curveIndexSelected] = colorNew;
														curvesColorsSerialized.ValueChanged ();
														curvesColorsSerialized.ApplyModifiedValue ();
							
							
												}
						
										} else {
						
						
						
												propertyPopupLabel.text = "Select blackboard var";
						
						
												List<UnityVariable> blackboardLocalList = __mecanimNode.blackboard.GetVariableBy (typeof(float));
						
												List<GUIContent> displayOptionsList = blackboardLocalList.Select ((item) => new GUIContent ("Local/" + item.name)).ToList ();
						
						
						
						
												_variableSelected = EditorGUILayoutEx.UnityVariablePopup (new GUIContent ("Var:"), _variableSelected, typeof(float), displayOptionsList, blackboardLocalList);
						
						
						
						
						
						
												_colorSelected = EditorGUILayout.ColorField (_colorSelected);
						
										}
					
					
					
					
					
										/////////////// ADD CURVE(+) /////////
										if (GUILayout.Button ("Add") && _variableSelected != null) {
						
						
						
						
												List<UnityVariable> vList = variablesBindedToCurves.ToList ();
												vList.Add (_variableSelected);
												variablesBindedToCurvesSerialized.value = variablesBindedToCurves = vList.ToArray ();
												variablesBindedToCurvesSerialized.ValueChanged ();
												//variablesBindedToCurvesSerialized.ApplyModifiedValue ();
						
						
						
						
						
						
												List<Color> cList = curveColors.ToList ();
												_colorSelected.a = 1;
												cList.Add (_colorSelected);
												curvesColorsSerialized.value = curveColors = cList.ToArray ();
												curvesColorsSerialized.ValueChanged ();	
												//curvesColorsSerialized.ApplyModifiedValue ();		
						
						
						
						
						
						
												AnimationCurve curveAnimationNew;
						
						
						
												List<AnimationCurve> crList = curves.ToList ();
						
												curveAnimationNew = new AnimationCurve (new Keyframe[] {
							new Keyframe (0f, (float)_variableSelected.Value),
							new Keyframe (1f, 1f)
						});
						
												//TODO add from preset
												crList.Add (curveAnimationNew);
						
												curvesSerialized.value = curves = crList.ToArray ();
												curvesSerialized.ValueChanged ();
												//curvesColorsSerialized.ApplyModifiedValue ();
						
						
						
												///add curve wrapped to CurveEditor
												CurveWrapperW curveWrapperW = new CurveWrapperW ();
						
												curveWrapperW.color = _colorSelected;
						
												curveWrapperW.curve = curveAnimationNew;
						
												curveEditor.AddCurve (curveWrapperW);
						
												curveEditor.FrameSelected (true, true);
						
						
						
												__serializedNode.Update ();
						
												__serializedNode.ApplyModifiedProperties ();
						
						
												_variableSelected = null;
						
										}



										/// DELETE CURVE ///
										if (GUILayout.Button ("Del") || Event.current.keyCode == KeyCode.Delete) {
						
						
												curveEditor.RemoveCurveAt (_curveIndexSelected);
						
						
						
												List<UnityVariable> vList = variablesBindedToCurves.ToList ();
												vList.RemoveAt (_curveIndexSelected);
												variablesBindedToCurvesSerialized.value = variablesBindedToCurves = vList.ToArray ();
												variablesBindedToCurvesSerialized.ValueChanged ();
						
						
						
						
						
												List<Color> cList = curveColors.ToList ();
						
												cList.RemoveAt (_curveIndexSelected);
												curvesColorsSerialized.value = curveColors = cList.ToArray ();
												curvesColorsSerialized.ValueChanged ();
						
						
						
						
						
												List<AnimationCurve> crList = curves.ToList ();
						
												crList.RemoveAt (_curveIndexSelected);
						
												curvesSerialized.value = curves = crList.ToArray ();
												curvesSerialized.ValueChanged ();
						
						
						
						
												_curveIndexSelected = -1;
												_variableSelected = null;
						
												__serializedNode.ApplyModifiedProperties ();
						
						
										}
					
					
					
				
					
					
										EditorGUILayout.EndHorizontal ();



				


								} else {//NOT CURVE EDITOR



										///////////// GAMEOBJECT - CLIP BINDINGS //////////
								
										__gameObjectClipList.DoLayoutList ();


										//////////////////////////////////////////////

								}



				EditorGUILayout.Space();


								/////////////   TIME CONTROL OF ANIMATION (SLIDER) /////////
					
								Rect timeControlRect = GUILayoutUtility.GetRect (Screen.width, 26f);

								
							

								timeControlRect.xMax = 32f;

							


								__isPlaying = GUI.Toggle (timeControlRect, __isPlaying, !__isPlaying ? TimeControlW.style.playIcon : TimeControlW.style.pauseIcon, TimeControlW.style.playButton);


				if (__isPlaying) {
					
					
					
				} else {
					
					
					
				}		


								timeControlRect.xMin = timeControlRect.xMax + 1f;
								timeControlRect.xMax =timeControlRect.xMin+ 21f;
								timeControlRect.yMin+=2f;
				
								__isRecording = GUI.Toggle (timeControlRect, !__isRecording, TimeControlW.style.recordIcon, EditorStyles.toolbarButton);


				if (__isRecording) {
					
					
					
				} else {
					
					
					
				}

								timeControlRect.xMin = 40f + 16f;
								timeControlRect.xMax = Screen.width - 68f;
								timeControlRect.yMin-=2f;

								timeNormalized = EditorGUILayoutEx.CustomHSlider (timeControlRect, timeNormalized, 0f, 1f, TimeControlW.style.timeScrubber);

								
									









								///////////////////////////////////////////////////////////////



								//////////////////////////////////////////////////////////////
								/// 
								///			 Draw red time scrubber line on top of Curve Editor 
								///
								//////////////////////////////////////////////////////////////
				
								if (_curvesEditorShow) {
										Handles.color = Color.red;
				
				
				
										float leftrightMargin = 39f;// 40f;
										float effectiveWidth = curveEditorRect.width - 2 * leftrightMargin - curveEditorRect.xMin;
										float timeLineX = curveEditorRect.xMin + leftrightMargin + effectiveWidth * timeNormalized;
				
										Handles.DrawLine (new Vector2 (timeLineX, curveEditorRect.y), new Vector2 (timeLineX, curveEditorRect.y + curveEditorRect.height));
								}

					
					
					
								////////// EVALUTE CURVES //////////
								int variablesNum = variablesBindedToCurves.Length;
								for (int varriableCurrentinx=0; varriableCurrentinx<variablesNum; varriableCurrentinx++) {
						
						
										variablesBindedToCurves [varriableCurrentinx].Value = curves [varriableCurrentinx].Evaluate (timeNormalized);
								}
					
					
					

				
								//////////  MOTION OVERRIDE HANDLING  //////////

								UnityEngine.Motion motion = null;
					
								UnityVariable motionOverridVariable = (UnityVariable)motionOverrideSerialized.value;
					
								//if there are no override use motion of selected AnimationState
								//Debug.Log(((UnityEngine.Object)mecanimNode.motionOverride.Value).);
								if (motionOverridVariable == null || motionOverridVariable.Value == null || motionOverridVariable.ValueType != typeof(AnimationClip))
										motion = ((ws.winx.unity.AnimatorState)animatorStateSerialized.value).motion;
								else //
										motion = (UnityEngine.Motion)motionOverridVariable.Value;
					
					
					
								if (motionOverridVariable != null && motionOverridVariable.Value != null && ((ws.winx.unity.AnimatorState)animatorStateSerialized.value).motion == null) {
										Debug.LogError ("Can't override state that doesn't contain motion");
								}
					
					

		

					
					
					
						}				
				
				
				
				
				

						

				
				}

		}
}

